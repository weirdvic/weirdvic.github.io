<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Блог on Цифровой мицелий</title>
        <link>https://weirdvic.github.io/posts/</link>
        <description>Recent content in Блог on Цифровой мицелий</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ru-ru</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 19 Jul 2023 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://weirdvic.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Красный дракон</title>
            <link>https://weirdvic.github.io/posts/%D0%BA%D1%80%D0%B0%D1%81%D0%BD%D1%8B%D0%B9-%D0%B4%D1%80%D0%B0%D0%BA%D0%BE%D0%BD/</link>
            <pubDate>Sun, 09 Jul 2023 00:00:00 +0300</pubDate>
            
            <guid>https://weirdvic.github.io/posts/%D0%BA%D1%80%D0%B0%D1%81%D0%BD%D1%8B%D0%B9-%D0%B4%D1%80%D0%B0%D0%BA%D0%BE%D0%BD/</guid>
            <description>Предыстория Я играю в NetHack уже очень-очень давно. Моё первое непродолжительное знакомство с этой игрой состоялось приблизительно в 2006 году, но на тот момент моего знания английского не хватало на то чтобы полноценно начать играть. Постоянного доступа к интернету для общения с другими игроками у меня в то время не было, сама игра очень сложная без подсказок, так что довольно скоро я оставил попытки и не прошёл даже Гномьи Шахты.</description>
            <content type="html"><![CDATA[<figure><img src="/ox-hugo/nhsplash.png"/>
</figure>

<h2 id="предыстория">Предыстория</h2>
<p>Я играю в <a href="https://nethack.org/">NetHack</a> уже очень-очень давно. Моё первое непродолжительное знакомство с этой игрой состоялось приблизительно в 2006 году, но на тот момент моего знания английского не хватало на то чтобы полноценно начать играть. Постоянного доступа к интернету для общения с другими игроками у меня в то время не было, сама игра очень сложная без подсказок, так что довольно скоро я оставил попытки и не прошёл даже Гномьи Шахты. Снова вернулся к этой игре я лишь спустя пять лет, уже будучи студентом. Фактически NetHack является той игрой, которая прошла со мной через годы, в которую я играл и играю в разных версиях, на разных устройствах и которая всё ещё имеет огромный простор для реиграбельности и много тайн.</p>
<p>Одной из таких загадок для меня являлось изображение всадника на красном драконе, появляющееся при запуске графической версии NetHack на Windows, да и на других платформах думаю тоже. И хоть практически с самого начала я играю в режиме без тайлсетов в текстовой псевдографике, этот всадник на дракончике чем-то запал в мою память ещё со школьных лет, когда я впервые запускал NetHack 3.4.3 на компьютере с Windows XP и безуспешно пытался исследовать жестокий мир игры.</p>
<h2 id="история">История</h2>
<p>И вот, уже в 2023 году я наконец-то решил разобраться с историей происхождения этой картинки. Начал, как говорится, с начала — с поисков в <a href="https://github.com/NetHack/NetHack">исходном коде игры</a>, который уже довольно давно доступен на GitHub. В исходниках графической версии довольно быстро нашёлся <a href="https://github.com/NetHack/NetHack/blob/NetHack-3.7/win/share/nhsplash.xpm">файл</a> с самим изображением всадника из заголовка этой статьи.</p>
<p>Сейчас я понимаю, что если бы копнул чуть глубже в исходниках, смог бы найти имя автора изображения и уже по имени автора найти исходник. Но об этом чуть позднее. Чтобы установить происхождение драконьего всадника, я создал пост с вопросом в сабреддите <a href="https://www.reddit.com/r/nethack/">r/nethack</a>, где довольно быстро получил ответ — оригинальное изображение участвовало в <a href="https://www.irtc.org/">The Internet Raytracing Competition</a> в 1997 году.</p>
<p>&ldquo;Dragon Rider&rdquo; (1997) by Warwick Allison:
<img src="/ox-hugo/dragonri.jpg" alt=""></p>
<p>Уже интереснее! Вместе с изображением доступен <a href="https://www.irtc.org/ftp/pub/stills/1997-08-31/dragonri.txt">текстовый файл</a> с указанием авторства и заметкой от том, как было создано конкурсное изображение.</p>
<p>Сначала немного об авторе: это некий Warwick Allison, судя по всему, он был участником DevTeam и поддерживал Qt версию NetHack в нулевых и поэтому добавил свою картинку с драконом. Кроме того он приложил руку и к другим opensource играм, например к <a href="http://freeciv.org/">Freeciv</a>. Похоже <a href="https://www.youtube.com/@WarwickAllison">этот канал</a> на YouTube принадлежит ему же, но я не пытался с ним связаться.</p>
<p>Но что <strong>действительно</strong> интересно — вместе с готовыми рендерами и текстовыми файлами на сайте IRTC до сих пор доступны архивы с исходниками и в этот момент я задался целью сделать &ldquo;HD ремастер&rdquo; драконьего всадника.</p>
<h2 id="технологии-древних">Технологии древних</h2>
<p>После прочтения текстового файла от автора оригинального изображения, я узнал новое для себя слово POV-Ray и открыл для себя древние технологии трёхмерной графики в эпоху до современных редакторов.</p>
<p>Если пытаться объяснить простым языком, то <a href="http://www.povray.org/">POV-Ray</a> это специальная программа, которая принимает на вход текстовые файлы, содержащие описание трёхмерной сцены(геометрия объектов, расположение камеры, источники освещения, различные эффекты) на специальном языке, а на выходе генерирует растровый графический файл. Из плюсов такого подхода: низкие требования к системе, для работы достаточно текстового редактора, а сам рендер можно запускать на другой машине. Описание сцены по-сути представляет собой программу, получается такой CGI as a code подход, что интересно само по себе. Из очевидных минусов — невозможность смотреть изменения в реальном времени, но с учётом скорости рендера на современных компьютерах и возможности во время разработки использовать низкие настройки качества, это не такая уж и проблема.</p>
<p>Проект продолжает развиваться, несмотря на свой возраст, кроме уже упомянутого IRTC на официальном сайте есть <a href="https://hof.povray.org/">галерея</a> избранных работ. POV-Ray также используется для создания иллюстраций к различным научным статьям, а кроме того для создания анимаций. Сложилось впечатление, что сейчас это такой не мейнстримный способ создания трёхмерной графики, который может быть даже удобнее условного Blender, например для визуализации научных данных.</p>
<p>Моя же затея состояла в том чтобы запустить рендеринг исходного изображения с драконьим всадником, используя современную версию POV-Ray и в высоком разрешении. Оригинал был сделан для версии POV-Ray 3.0, я же адаптировал код для актуальной 3.7. Изменений пришлось сделать немного: с определённой версии точки с запятой в конце строк стали обязательными, так что пришлось их добавить и отдельно пришлось разобраться как переписать на современную версию свечение вокруг навершия посоха всадника.</p>
<ul>
<li>Вот та же картинка, но в разрешении 1900*1080:</li>
</ul>
<figure><img src="/ox-hugo/dragonrider.png"/>
</figure>

<ul>
<li>Кроме того, поскольку мы работаем с исходным кодом, можно проворачивать интересные штуки, например изменить цвета(здесь изображение растянуто вдоль горизонтали потому что на тот момент я ещё не разобрался как указать правильный aspect ratio):</li>
</ul>
<figure><img src="/ox-hugo/dragonrider_blue.png"/>
</figure>

<ul>
<li>Или взглянуть на сцену с другого положения камеры(в коде было закомментировано несколько позиций для камеры):</li>
</ul>
<figure><img src="/ox-hugo/distance.png"/>
</figure>

<ul>
<li>Ну и наконец, отдельные элементы сцены могут включаться и выключаться условными блоками, так что можно отключить всё кроме дракона и всадника и получить улучшенную версию картинки из начала статьи:</li>
</ul>
<figure><img src="/ox-hugo/dragonrider_no_background.png"/>
</figure>

<h2 id="итоги">Итоги</h2>
<p>Мне нравится такого рода &ldquo;цифровая археология&rdquo;. Вдвойне приятно найти пример технологии, которая жизнеспособна и даже обратно совместима на временном промежутке в 25 лет. Кроме удовлетворения любопытства узнал немного больше об истории и технологиях трёхмерной графики, сделал себе несколько крутых обоин на рабочий стол в ретро стиле и в целом интересно провёл время. Мне кажется что POV-Ray это возможность заниматься 3D как хобби если ты больше программист чем художник.</p>
]]></content>
        </item>
        
        <item>
            <title>Установка Minikube в Oracle Linux</title>
            <link>https://weirdvic.github.io/posts/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-minikube-%D0%B2-oracle-linux/</link>
            <pubDate>Tue, 30 May 2023 00:00:00 +0300</pubDate>
            
            <guid>https://weirdvic.github.io/posts/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-minikube-%D0%B2-oracle-linux/</guid>
            <description>Введение В этой статье я бы хотел зафиксировать процесс запуска учебного кластера Kubernetes в виде Minikube на сервере под управлением Oracle Linux.
Подразумевается что сам сервер с доступом по ssh у нас уже есть. Я использую бесплатный инстанс в Oracle Cloud, но в принципе можно использовать любое другое облако или даже любой другой хостинг, вплоть до подкроватного. Для запуска Minikube необходимо минимум 2 ядра процессора и 2 Гб оперативной памяти. Если мы используем free-tier облака от Oracle, то следует использовать машины на Ampere A1.</description>
            <content type="html"><![CDATA[<h2 id="введение">Введение</h2>
<p>В этой статье я бы хотел зафиксировать процесс запуска учебного кластера <a href="/mycelium/kubernetes/">Kubernetes</a> в виде <a href="/mycelium/minikube/">Minikube</a> на сервере под управлением  <a href="/mycelium/oracle-linux/">Oracle Linux</a>.</p>
<p>Подразумевается что сам сервер с доступом по ssh у нас уже есть. Я использую бесплатный инстанс в <a href="https://cloud.oracle.com">Oracle Cloud</a>, но в принципе можно использовать любое другое облако или даже любой другой хостинг, вплоть до подкроватного. Для запуска Minikube <a href="https://minikube.sigs.k8s.io/docs/start/#what-youll-need">необходимо минимум</a> 2 ядра процессора и 2 Гб оперативной памяти.
Если мы используем free-tier облака от Oracle, то следует использовать машины на Ampere A1. Бесплатных лимитов хватает либо на то чтобы создать 2 машины с двумя ядрами, либо одну с четырьмя.</p>
<p>Я использую свою виртуальную машину для изучения Oracle Linux и <a href="/mycelium/podman/">Podman</a>. Также нам понадобятся установленные на хосте cURL и <a href="/mycelium/nginx/">Nginx</a>. Для генерации пароля нам понадобится утилита <code>htpasswd</code>, в Oracle Linux она входит в пакет с названием <code>httpd-tools</code>. Я буду делать доступ с привязкой домена, для наших целей подойдёт любой домен, вплоть до бесплатных от <a href="https://www.freenom.com">Freenom</a>. Для большей безопасности и других бонусов я использую прокси от <a href="/mycelium/cloudflare/">Cloudflare</a>. Обо всём этом подробнее дальше.</p>
<h2 id="устанавливаем-minikube">Устанавливаем Minikube</h2>
<p>Сама по себе установка Minikube довольно простая и описана в <a href="https://minikube.sigs.k8s.io/docs/start/">документации</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64
</span></span><span style="display:flex;"><span>sudo install minikube-linux-arm64 /usr/local/bin/minikube
</span></span></code></pre></div><p>После этого необходимо создать кластер. Мы используем Podman, это явно нужно указать при создании:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>minikube start --driver<span style="color:#f92672">=</span>podman
</span></span></code></pre></div><p>После окончания создания кластера, им уже можно пользоваться на удалённой машине, для проверки работоспособности предлагается выполнить команду:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>minikube kubectl -- get pods -A
</span></span></code></pre></div><p>Если всё хорошо, можем двигаться дальше.</p>
<h2 id="планируем-удалённый-доступ">Планируем удалённый доступ</h2>
<p>Кластер доступен на самом сервере, а мы хотим работать с ним с нашей локальной машины, как поступить в данном случае? По-умолчанию API-сервер Minikube принимает только локальные соединения, а значит нам понадобится настроить Nginx в качестве <a href="/mycelium/%D1%80%D0%B5%D0%B2%D0%B5%D1%80%D1%81-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8/">реверс-прокси</a>, который будет принимать авторизованные запросы на внешний IP нашего сервера и проксировать их на внутренний адрес API Kubernetes.</p>
<p>Иными словами, я хочу достигнуть следующей схемы:</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<figure><img src="/ox-hugo/minikube-access-diagram.svg"
         alt="Figure 1: Схема доступа к Minikube на сервере."/><figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->Схема доступа к Minikube на сервере.</p>
        </figcaption>
</figure>

<p>Мы будем отправлять команды при помощи локального kubectl, запросы к API будут уходить на специальный домен или поддомен за <a href="/mycelium/cloudflare/">Cloudflare</a>, оттуда проксироваться на виртуальную машину с запущенным <a href="/mycelium/minikube/">Minikube</a>. На самой машине хостовый <a href="/mycelium/nginx/">Nginx</a> будет принимать подключения, проверять базовую авторизацию и проксировать доверенные подключения на локальный адрес Minikube.</p>
<h2 id="настройка-nginx-на-сервере">Настройка Nginx на сервере</h2>
<p>Начнём с простого — сгенерируем пароль для защиты нашего подключения, в этой команде <code>minikube</code> — имя пользователя для HTTP авторизации:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sudo htpasswd -c /etc/nginx/.htpasswd minikube
</span></span></code></pre></div><p>Для примера можем использовать пароль <code>b3VyU3VwZXJTZWNyZXRQYXNzd29yZAo=</code>.</p>
<p>Разумеется, пароль надо где-нибудь сохранить, он нам ещё понадобится.</p>
<p>Для того чтобы наш Nginx мог проксировать запросы к Kubernetes API, ему нужны SSL сертификаты и здесь у меня возникла путаница. Поскольку Podman не требует запуска от root-пользователя, Minikube через Podman можно запускать от обычного пользователя. Следовательно, конфиг Minikube будет храниться в домашней директории обычного пользователя(в моих примерах стандартное имя пользователя <code>opc</code>) и файлы из него не будут доступны другим пользователям(например <code>nginx</code>). Самым простым решением будет скопировать файлы ключа и сертификата в директорию Nginx.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sudo mkdir -p /etc/nginx/certs
</span></span><span style="display:flex;"><span>sudo cp /home/opc/.minikube/profiles/minikube/client.key /etc/nginx/certs/minikube-client.key
</span></span><span style="display:flex;"><span>sudo cp /home/opc/.minikube/profiles/minikube/client.key /etc/nginx/certs/minikube-client.key
</span></span></code></pre></div><p>После этого можем создать конфиг реверс-прокси Nginx. У меня используется SSL сертификаты от Cloudflare, приведу пример той части конфига, которая нас интересует:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#75715e"># В http блоке добавляем такую штуку, это способ создать &#34;глобальную переменную&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># в конфиге Nginx и в дальнейшем использовать её в разных других блоках.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># Быстро узнать адрес API Minikube можно командой minikube ip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">map</span> $host $MINIKUBE_IP {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">default</span> <span style="color:#e6db74">&#34;192.168.49.2&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Ниже идёт серверный блок для приёма входящих подключений с авторизацией
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># В примере используется субдомен k.examplehomelab.tk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># Сам субдомен предварительно нужно создать в Cloudflare, а также скачать
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># сертификат и ключ для главного домена. Настройка SSL для Cloudflare это
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># не очень сложная, хоть и обширная тема, материалов по которой много.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># https://developers.cloudflare.com/ssl/get-started/
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">server</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">listen</span>       <span style="color:#ae81ff">443</span> <span style="color:#e6db74">ssl</span> <span style="color:#e6db74">http2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Используем имя субдомена
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">server_name</span>  <span style="color:#e6db74">k.examplehomelab.tk</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Используем сертификат основного домена, благо Cloudflare даёт
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e"># wildcard сертификат типа *.examplehomelab.tk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">ssl_certificate</span> <span style="color:#e6db74">&#34;/etc/nginx/ssl/examplehomelab.tk.pem&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ssl_certificate_key</span> <span style="color:#e6db74">&#34;/etc/nginx/ssl/examplehomelab.tk.key&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ssl_session_cache</span> <span style="color:#e6db74">shared:SSL:1m</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ssl_session_timeout</span>  <span style="color:#ae81ff">10m</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ssl_ciphers</span> <span style="color:#e6db74">PROFILE=SYSTEM</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ssl_prefer_server_ciphers</span> <span style="color:#66d9ef">on</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">auth_basic</span> <span style="color:#e6db74">&#34;Administrator’s</span> <span style="color:#e6db74">Area&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Путь к нашему файлу для проверки авторизации
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">auth_basic_user_file</span> <span style="color:#e6db74">/etc/nginx/.htpasswd</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Собственно настройка проксирования запросов к API
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">location</span> <span style="color:#e6db74">/</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_http_version</span> <span style="color:#ae81ff">1</span><span style="color:#e6db74">.1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_pass</span> <span style="color:#e6db74">https://</span>$MINIKUBE_IP:8443;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Host</span> $host;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">X-Real-IP</span> $remote_addr;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">X-Forwarded-For</span> $proxy_add_x_forwarded_for;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Upgrade</span> $http_upgrade;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Connection</span> <span style="color:#e6db74">&#34;upgrade&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># А здесь сертификат для общения с API Minikube по HTTPS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">proxy_ssl_certificate</span> <span style="color:#e6db74">/etc/nginx/certs/minikube-client.crt</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">proxy_ssl_certificate_key</span> <span style="color:#e6db74">/etc/nginx/certs/minikube-client.key</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Конечно, конфиг не идеален, но для моего сценария использования вполне подходит. Выполняем стандартные манипуляции чтобы обновить конфиг:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sudo nginx -t
</span></span><span style="display:flex;"><span>sudo service nginx reload
</span></span></code></pre></div><p>На этом этапе уже можно попробовать открыть наш адрес в браузере, если всё настроено корректно, браузер запросит авторизацию, а после ввода логина(<code>minikube</code>) и пароля(<code>b3VyU3VwZXJTZWNyZXRQYXNzd29yZAo=</code>) мы увидим список доступных путей Kubernetes API. Можем двигаться дальше, к настройке локального kubectl.</p>
<h2 id="настройка-kubectl">Настройка kubectl</h2>
<p>Настал момент настроить подключение к кластеру с нашей локальной машины. По-умолчанию на сервере конфигурация Minikube хранится в файле <code>~/.kube/config</code>. Скопируем этот файл к себе на машину по тому же пути, он будет выглядеть примерно так:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">clusters</span>:
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">cluster</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">certificate-authority</span>: <span style="color:#ae81ff">/home/opc/.minikube/ca.crt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">extensions</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">extension</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">last-update</span>: <span style="color:#ae81ff">Tue, 30 May 2023 13:39:51 GMT</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">provider</span>: <span style="color:#ae81ff">minikube.sigs.k8s.io</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">version</span>: <span style="color:#ae81ff">v1.30.1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">cluster_info</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">https://192.168.49.2:8443</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">minikube</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">contexts</span>:
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">context</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">cluster</span>: <span style="color:#ae81ff">minikube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">extensions</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">extension</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">last-update</span>: <span style="color:#ae81ff">Tue, 30 May 2023 13:39:51 GMT</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">provider</span>: <span style="color:#ae81ff">minikube.sigs.k8s.io</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">version</span>: <span style="color:#ae81ff">v1.30.1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">context_info</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">default</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">user</span>: <span style="color:#ae81ff">minikube</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">minikube</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">current-context</span>: <span style="color:#ae81ff">minikube</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">preferences</span>: {}
</span></span><span style="display:flex;"><span><span style="color:#f92672">users</span>:
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">minikube</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">user</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">client-certificate</span>: <span style="color:#ae81ff">/home/opc/.minikube/profiles/minikube/client.crt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">client-key</span>: <span style="color:#ae81ff">/home/opc/.minikube/profiles/minikube/client.key</span>
</span></span></code></pre></div><p>Нужно поправить пару мест.</p>
<ol>
<li>Заменяем <code>server: https://192.168.49.2:8443</code> на наш внешний адрес сервера.</li>
<li>В конце файла закомментировать или удалить строчки <code>client-certificate</code> и <code>client-key</code>, а вместо них добавить <code>username</code> со значением <code>minikube</code> и <code>password</code> со значением нашего пароля для HTTP авторизации.</li>
</ol>
<p>Сохраняем файл и проверяем работоспособность:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>kubectl get all -A
</span></span></code></pre></div><p>Для дополнительной безопасности ещё можно использовать правила Cloudflare чтобы ограничить доступ к API по стране или IP адресу если он у вас статический.</p>
<p>На этом всё, в дальнейшем можно работать с кластером так же как и с запущенным локально Minikube.</p>
]]></content>
        </item>
        
        <item>
            <title>Миграция в org-roam</title>
            <link>https://weirdvic.github.io/posts/%D0%BC%D0%B8%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-org-roam/</link>
            <pubDate>Fri, 12 May 2023 00:00:00 +0300</pubDate>
            
            <guid>https://weirdvic.github.io/posts/%D0%BC%D0%B8%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-org-roam/</guid>
            <description>Недавно я начал использовать org-roam для управления своими заметками при помощи Emacs. Самим Emacs я пользуюсь уже довольно давно, но перечень задач, выполняемый в этой прекрасной &amp;ldquo;операционной системе&amp;rdquo; периодически изменяется. Прелесть Emacs, как многие уже отмечали, в том что это не цель, но путь. Можно начать использовать его как простой текстовый редактор, а затем постепенно добавлять или убирать функции, подстраивая систему под свой рабочий процесс. Часто это означает что ты перестаёшь пользоваться отдельной программой потому что её функции доступны и в Emacs.</description>
            <content type="html"><![CDATA[<p>Недавно я начал использовать <a href="https://www.orgroam.com/">org-roam</a> для управления своими заметками при помощи Emacs. Самим Emacs я пользуюсь уже довольно давно, но перечень задач, выполняемый в этой прекрасной &ldquo;операционной системе&rdquo; периодически изменяется. Прелесть Emacs, как многие уже отмечали, в том что это не цель, но путь. Можно начать использовать его как простой текстовый редактор, а затем постепенно добавлять или убирать функции, подстраивая систему под свой рабочий процесс. Часто это означает что ты перестаёшь пользоваться отдельной программой потому что её функции доступны и в Emacs. Так было у меня с отдельным эмулятором терминала когда я открыл для себя <a href="https://github.com/akermu/emacs-libvterm">vterm</a>. В другой раз я попытался настроить Emacs для работы с базами данных, но довольно быстро понял что использовать отдельный специализировнный инструмент в виде <a href="https://dbeaver.io/">DBeaver</a> лично мне намного удобнее. В этот же раз речь пойдёт о задаче ведения заметок и о том как это <em>можно</em> делать при помощи Emacs.</p>
<p>Для ведения различных рабочих и не очень заметок в последние годы я использовал <a href="https://orgmode.org/">org-mode</a> в самом базовом варианте. У меня был один единственный файл <code>~/work.org</code>, в который каждый рабочий день за каждым рабочим днём я добавлял записи о том чем занимался вчера и чем планирую заняться сегодня. Выглядело это упрощённо вот так:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-org" data-lang="org"><span style="display:flex;"><span>*<span style="font-weight:bold"> [2020-02-19]</span>
</span></span><span style="display:flex;"><span>Что сделал:
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">- </span>Задача 1…
</span></span><span style="display:flex;"><span>  Подробности по задаче
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">- </span>Задача 2…
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">- </span>Задача 3…
</span></span><span style="display:flex;"><span>Что сделать:
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">- [X]</span> Задача 1…
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">- [ ]</span> Задача 2…
</span></span><span style="display:flex;"><span>  Подробное описание задачи 2…
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">- [X]</span> Задача 3…
</span></span></code></pre></div><p>Такой способ организации и ведения заметок может показаться примитивным, но на период когда я им пользовался, это был идеальный баланс между удобством ведения такого журнала и пользой от его ведения. Иногда всё что требуется сохранить это простой список дел, которые нужно отмечать в течение дня, какой-то кусок кода или ссылку и не более того. Конечно, я рассматривал и альтернативы вроде <a href="https://keep.google.com">Google Keep</a>, но в конечном итоге оказалось что ведение заметок в Emacs лично мне удобнее, а необходимости часто делиться содержимым заметок с кем-либо у меня нет.</p>
<p>Так или иначе, в определённый момент я стал использовать org-mode и для не связанных с работой заметок, например для хобби-проектов. Стали появляться новые org файлы, разбросанные по разным местам и никак не систематизированные. Кроме того, во время прохождения различных курсов и туториалов полезно делать хоть небольшие конспекты, которые также нужно где-то сохранять. Был соблазн собрать вообще все заметки в один мастер-файл <code>notes.org</code> и я знаю что некоторые пользователи Emacs придерживаются такого подхода. Но мне захотелось более структурированного решения для создания персональной базы знаний с возможностями поиска, отсутствием привязки к сторонним онлайн сервисам и удобным интерфейсом. Разворачивание собственной вики показалось громоздким, онлайн сервисы типа <a href="https://www.notion.so/">Notion</a> мне не нравятся именно из-за онлайновости и проблем с доступностью функций и самих данных: сегодня функция n есть в бесплатном тарифе, завтра она может оказаться уже только в платном, а послезавтра сделают премиум фичей экспорт данных из сервиса.</p>
<p>В общем, под мои пожелания в итоге подошли два продукта: <a href="https://obsidian.md/">Obsidian</a> и уже упомянутый <a href="https://www.orgroam.com/">org-roam</a>. Обе системы предназначены для ведения базы связанных между собой заметок, хранят данные в локально в простом текстовом формате и обладают возможностями расширения за счёт плагинов в случае Obsidian и за счёт мощи Emacs Lisp в случае org-roam. При этом порог вхождения однозначно ниже у Obsidian, с которого я и решил начать. Программа кроссплатформенная, легко устанавливается (в случае с Linux можно даже просто скачать и запустить AppImage файл), читать документацию чтобы просто начать добавлять заметки не требуется, интерфейс можно сказать интуитивный. В целом впечатления от использования очень приятные, наверное лучший вариант в своей категории если вы не пользователь Emacs. Я же пользуюсь Emacs и через несколько дней работы с Obsidian понял что держать отдельную программу только для заметок мне не нравится. И так хватает двух браузеров (Firefox и Chromium) и двух мессенджеров (Telegram и рабочий Google Chat) чтобы ещё держать рядом с работающим Emacs параллельно запущенный Obsidian. Кстати говоря, перенос мессенджеров внутрь Emacs это тоже вполне реально, но об этом в другой раз. Примерно через неделю использования Obsidian я решил что всё же стоит потратить время и усилия на конфиг Emacs и перейти на org-roam.</p>
<p>Что представляет из себя org-roam? Сайт проекта говорит об &ldquo;a plain-text personal knowledge management system&rdquo; и по-сути так оно и есть. Org-roam это система, построенная поверх емаксового org-mode и позволяющая структурированно хранить заметки в org файлах со связями между заметками для организации базы знаний. Хороший ресурс для начала знакомства с системой это её <a href="https://www.orgroam.com/manual.html">мануал</a>, в котором описаны базовые функции, вводится терминология и приводятся примеры конфигурации Emacs для начала работы. После прочтения мануала начинается увлекательный процесс допиливания системы под свои потребности aka &ldquo;копипаст и переписывание кусков кода из чужих конфигов&rdquo;.</p>
<p>Одна из сильных сторон Emacs и одновременно его слабостей (см. <a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html">The Lisp Curse</a>) — очень редко есть единственный популярный и поддерживаемый способ делать что-либо. С одной стороны существование альтернатив это хорошо, но с другой это усложняет выбор обучение в случае если ты совсем новичок и для тебя все альтернативы отличаются лишь названиями. Причём эта особенность присутствует практически на всех уровнях взаимодействия с Emacs. Сейчас наиболее используемой версией Emacs является <a href="https://www.gnu.org/software/emacs/">GNU Emacs</a>, но были времена когда существовала альтернатива в виде <a href="http://www.xemacs.org/">XEmacs</a>. Сам GNU Emacs нынче можно установить как в относительно ванильной версии, так и в виде преднастроенных &ldquo;дистрибутивов&rdquo; вроде <a href="https://docs.doomemacs.org/latest/">Doom Emacs</a> или <a href="https://www.spacemacs.org/">Spacemacs</a>. Внутри самого Emacs существует сильно больше одного способа управления сторонними пакетами, лично я пользуюсь <a href="https://jwiegley.github.io/use-package/">use-package</a>. Даже для org-roam как системы ведения заметок существует своя альтернатива — <a href="https://protesilaos.com/emacs/denote">Denote</a> и в ходе поиска информации по настройкам org-roam я встречал упоминания о том что иногда люди переходят с одной системы на другую.</p>
<p>В ходе настройки своего Emacs я использовал эти статьи:</p>
<ul>
<li><a href="https://honnef.co/articles/my-org-roam-workflows-for-taking-notes-and-writing-articles/">My org-roam workflows for taking notes and writing articles</a></li>
<li><a href="https://hugocisneros.com/blog/my-org-roam-notes-workflow">My Org Roam Notes Workflow</a></li>
</ul>
<p>И даже несмотря на всё это, меня удивило то как реализован поиск по заметкам в org-roam. А организован он почти что никак — в уже упомянутом стартовом мануале есть небольшой пункт про настройку полнотекстового поиска посредством <a href="https://jblevins.org/projects/deft/">Deft</a>, но на этом и всё. Deft, как уже можно догадаться, тоже не единственный в своём роде, как минимум есть <a href="https://sr.ht/~casouri/xeft/">Xeft</a>. Но вообще поиск по Реддиту и Гитхабу показал что пользователи org-roam готовят поиск по заметкам кому как нравится. Для себя я остановился на <a href="https://github.com/jgru/consult-org-roam">consult-org-roam</a>, его функция поиска использует <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> или обычный grep для поиска по файлам в org-roam.</p>
<p>Другой функцией, доступной из коробки в Obsidian является просмотр графа связей между отдельными заметками. Для org-roam существует пакет <a href="https://github.com/org-roam/org-roam-ui">org-roam-ui</a>, который просто  устанавливается в Emacs и позволяет по-всякому визуализировать связи между нодами:</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<figure><img src="/ox-hugo/org-roam-ui-01.png"
         alt="Figure 1: Связи между нодами org-roam на момент написания статьи"/><figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->Связи между нодами org-roam на момент написания статьи</p>
        </figcaption>
</figure>

<p>После настройки визуализации и создания первых заметок на различные темы надо было решить что сделать со старым файлом <code>~/work.org</code>. Вариантов было немного:</p>
<ul>
<li>Добавить файл в org-roam &ldquo;как есть&rdquo;. В таком случае на графе это была бы единственная точка.</li>
<li>Разделить файл на отдельные заметки по дням, и в дальнейшем создавать новые заметки с использованием org-roam daily.</li>
</ul>
<p>Я выбрал второй вариант, поэтому на графе много ни с чем не связанных нод. При желании их легко можно исключить из визуализации:</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<figure><img src="/ox-hugo/org-roam-ui-02.png"
         alt="Figure 2: Граф связей в org-roam без daily заметок"/><figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->Граф связей в org-roam без daily заметок</p>
        </figcaption>
</figure>

<p>Единый файл с заметками я разделил на отдельные файлы с помощью небольшого скрипта на Python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> re<span style="color:#f92672">,</span>hashlib<span style="color:#f92672">,</span>time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Задаём регулярное выражение, по которому будем определять, является ли</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># текущая строка заголовком первого уровня в оригинальном org файле.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># В моём случае все заголовки первого уровня в файле имеют такой формат:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># * [2020-02-19 Ср]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Собрать нужную регулярку можно на https://regex101.com/</span>
</span></span><span style="display:flex;"><span>headingRX <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>compile(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;^\*\s\[(\d</span><span style="color:#e6db74">{4}</span><span style="color:#e6db74">-\d</span><span style="color:#e6db74">{2}</span><span style="color:#e6db74">-\d</span><span style="color:#e6db74">{2}</span><span style="color:#e6db74">)\s[а-яА-я]{2,3}\]$&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Создаём хэш-объект, который будем использовать для генерации униальных ID</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># каждого создаваемого org-roam файла.</span>
</span></span><span style="display:flex;"><span>hasher <span style="color:#f92672">=</span> hashlib<span style="color:#f92672">.</span>md5()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">createOrgRoamFile</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;Создает новый org-roam файл с шаблоном текста.&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Получаем md5-хэш от значения текущей даты и текущего времени</span>
</span></span><span style="display:flex;"><span>    hasher<span style="color:#f92672">.</span>update(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>currentDate<span style="color:#e6db74">}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">{</span>time<span style="color:#f92672">.</span>time()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Хэш будет использоваться в качестве ID ноды в org-roam</span>
</span></span><span style="display:flex;"><span>    nodeID <span style="color:#f92672">=</span> hasher<span style="color:#f92672">.</span>hexdigest()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Создаем шаблон, который будет записан в начало org-roam файла.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># В минимальном варианте он будет выглядеть так:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># :PROPERTIES:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># :ID: &lt;nodeID&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># :END:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># #+title: &lt;currentDate&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># #+date: [&lt;currentDate&gt;]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Ниже будет собственно содержимое заметки.</span>
</span></span><span style="display:flex;"><span>    orgRoamTemplate <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;:PROPERTIES:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">:ID: </span><span style="color:#e6db74">{</span>nodeID<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">:END:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">#+title: </span><span style="color:#e6db74">{</span>currentDate<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">#+date: [</span><span style="color:#e6db74">{</span>currentDate<span style="color:#e6db74">}</span><span style="color:#e6db74">]</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Записываем шаблон в начало org-roam файла, используя currentDate в качестве названия файла.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>currentDate<span style="color:#e6db74">}</span><span style="color:#e6db74">.org&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>) <span style="color:#66d9ef">as</span> output_file:
</span></span><span style="display:flex;"><span>        output_file<span style="color:#f92672">.</span>write(orgRoamTemplate)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">splitOrgFile</span>(inputFileName:str<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;notes.org&#39;</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;Разделяет входной org-mode файл на отдельные ноды org-roam.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    В качестве имени файла по-умолчанию используется notes.org.&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># В переменной currentDate будет храниться дата из текущего заголовка.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Дата используется при генерации ID создаваемой org-roam ноды, в шаблоне</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># заметки, а также в качестве имени создаваемого файла.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> currentDate
</span></span><span style="display:flex;"><span>    currentDate <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(inputFileName, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> inputFile:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Буффер для временного хранения строк файла перед записью в org-roam</span>
</span></span><span style="display:flex;"><span>        buffer <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Читаем файл построчно</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> inputFile:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Если это первый найденный заголовок</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> currentDate <span style="color:#f92672">and</span> headingRX<span style="color:#f92672">.</span>match(line):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Извлекаем дату из заголовка и открываем новый файл</span>
</span></span><span style="display:flex;"><span>                currentDate <span style="color:#f92672">=</span> headingRX<span style="color:#f92672">.</span>search(line)<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                createOrgRoamFile()
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Если мы уже нашли заголовок и создали файл и текущая строка</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># не является заголовком, добавляем строку во временный буфер.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> currentDate <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> headingRX<span style="color:#f92672">.</span>match(line):
</span></span><span style="display:flex;"><span>                buffer<span style="color:#f92672">.</span>append(line)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Если же мы уже нашли заголовок и создали файл и текущая строка</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># является заголовком, значит текущая строка — это новый заголовок.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Записываем буфер в файл, очищаем его и создаём новый файл.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> currentDate <span style="color:#f92672">and</span> headingRX<span style="color:#f92672">.</span>match(line):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Дописываем содержимое буфера в текущий файл</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>currentDate<span style="color:#e6db74">}</span><span style="color:#e6db74">.org&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>) <span style="color:#66d9ef">as</span> output_file:
</span></span><span style="display:flex;"><span>                    output_file<span style="color:#f92672">.</span>writelines(buffer)
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># Очищаем буфер, извлекаем дату из нового заголовка</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># и создаём новый файл.</span>
</span></span><span style="display:flex;"><span>                    buffer <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>                    currentDate <span style="color:#f92672">=</span> headingRX<span style="color:#f92672">.</span>search(line)<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                    createOrgRoamFile()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>  __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    splitOrgFile()
</span></span></code></pre></div><p>И наконец, одной из самых интересных функций, которые можно реализовать в Emacs является генерация вебсайта из коллекции заметок. Как всегда есть несколько способов собирать сайт из org файлов, я решил использовать связку из org-roam и генератора статических сайтов <a href="/mycelium/hugo/">Hugo</a>. Собственно, удобство ведения блога из Emacs и привело к созданию этого сайта.</p>
<p>Посты в моём случае это просто заметки org-roam, которые содержат в блоке <code>:PROPERTIES:</code> параметр <code>:KIND: post</code>. После того как пост написан, достаточно нажать <code>C-c n p</code> и org файл будет экспортирован в Markdown, который потом используется Hugo для генерации HTML страницы сайта.</p>
<p>Предполагаю что настройка Emacs ещё неоднократно будет изменяться, поэтому смысла приводить здесь фрагменты кода нет. Актуальную версию можно посмотреть в моём <a href="https://github.com/weirdvic/.emacs.d">репозитории</a>.</p>
]]></content>
        </item>
        
    </channel>
</rss>
