+++
title = "SELinux"
date = 2023-08-05T00:00:00+03:00
lastmod = 2023-08-05
tags = ["Linux"]
draft = false
+++

## Общая информация {#общая-информация}

Security Enhanced Linux или SELinux это улучшенная система контроля доступа для операционных систем на базе Linux. SELinux использует подсистему ядра Linux под названием Linux Security Modules (LSM). Предназначение SELinux — создание дополнительного слоя управления доступом к компонентам системы поверх традиционного на основе пользователей, групп и аттрибутов файлов.

Изначально SELinux был разработан американским Агенством Национальной Безопасности в виде загружаемого модуля для ядра Linux. Подсистему LSM используют и другие проекты, связанные с безопасностью, такие как apparmor, tomoyo и smack. AppApmor по-умолчанию используется в современных версиях [Ubuntu]({{< relref "20230805105255-ubuntu_linux.md" >}}), а SELinux используется в дистрибутивах на основе RHEL и в Android.

Несмотря на то что SELinux включён по-умолчанию во многих распространённых дистрибутивах Linux, он до сих пор не является вещью, знакомой и понятной большинству разработчиков и администраторов. К тому же информация о практическом использовании SELinux разбросана по сайтам и форумам в интернете и зачастую является устаревшей. Попробуем разобраться как работать с SELinux и улучшить безопасность своих систем.


## Основы {#основы}

Одним из вопросов, возникающих при использовании многопользовательской операционной системы является вопрос владения. Например, пользователь может являться владельцем файлов. Из этого следует следующий вопрос: может ли пользователь взаимодействовать с файлами, принадлежащими другим пользователям? Для ответа на эти вопросы в системе реализуются различные механизмы контроля доступа(Access Control). Эти механизмы можно разделить на две группы:

-   Избирательный контроль доступа(Discretionary access control или DAC)
    -   Построен вокруг владельцев ресурсов.
    -   Владелец определяет кто обладает доступом к ресурсу.
    -   Примеры: стандартные права доступа в POSIX системах, права доступа NTFS.
-   Обязательный контроль доступа(Mandatory access control MAC)
    -   Менее распространён, построен вокруг самих ресурсов.
    -   Доступность к ресурсу определяется важностью самого ресурса.


## Архитектура SELinux {#архитектура-selinux}

В целом SELinux состоит из четырёх сущностей:

1.  **Subject** — субъект, запрашивающий действие, обычно это процесс(программа), который запрашивает доступ к ресурсу(файлу).
2.  **Object Manager** — менеджер объектов управляет доступом к ресурсам. Для разрешения или запрета доступа он обращается к серверу безопасности.
3.  **Security Server** — сервер, принимающий решение о разрешении или запрете доступа к ресурсу на основе политик безопасности. Может существовать только один Security Server, находящийся в ядре, но OM и AVC могут быть и как в ядре, так и в пространстве пользователя.
4.  **Access Vector Cache (AVC)** — кэш доступов, решения сервера сохраняются здесь для ускорения работы всей системы в целом.

Документация SELinux приводит такую схему:

{{< figure src="https://raw.githubusercontent.com/SELinuxProject/selinux-notebook/main/src/images/1-core.png" caption="<span class=\"figure-number\">Figure 1: </span>Взаимосвязь компонентов SELinux" >}}


## Понимание контекста SELinux {#понимание-контекста-selinux}

Традиционная система доступа в POSIX-совместимых системах состоит из трёх компонентов: права владельца, права группы и права остальных пользователей(мировые). Каждый компонент включает в себя права на чтение, запись и выполнение файла. Чтобы просмотреть права доступа файла `example` можно использовать `ls -l example`.

В отличие от этого, контекст безопасности SELinux привязан к субъектам(процессам) и объектам(ресурсам). Просмотреть контекст SELinux можно при помощи ключа `-Z` для той же команды. Контекст может выглядеть так: `system_u:object_r:passwd_file_t:s0 /etc/passwd`. Разберём составляющие `user:role:type:[:range]`:

-   **User** — пользователи SELinux отдельны от системных пользователей Linux и одному пользователю SELinux может соответствовать несколько системных. Имена пользователей SELinux обычно заканчиваются `_u`.
-   **Role** — роль в каком-то смысле аналог групп пользователей Linux и включает в себя несколько пользователей, объединённых общими задачами, например администраторов, администраторов базы данных, обычных пользователей.
-   **Type** — тип контекста очень важен в SELinux так как все правила основаны на типах.
-   **Range** — диапазон или приоритет важности это дополнительное поле контекста, выглядящее как `s#` где `#` это число. По соглашению, более низкие значения идут перед более высокими. Запись и чтение возможны только в пределах своего диапазона, из нижних диапазонов можно только читать, а в более высокие только записывать.


## Практическая часть {#практическая-часть}

В ходе использования и администрирования систем с SELinux часто возникают проблемы с разрешениями, особенно при установке нового софта. К счастью, SELinux обладает инструментами для диагностики и исправления таких проблем. Начнём с лога отказов в доступе и как с ним работать. Лог расположен в `/var/log/audit` либо в `/var/log/audit/audit.log`. Для более удобного поиска по логу есть специальная утилита `ausearch`.

После нахождения в логе информации об отказе доступа нужно понять требуется ли его разрешать. Мы можем написать правила вручную, либо использовать инструмент `audit2allow`, который получает данные из лога аудита и предлагает свои изменения.

Политики безопасности можно создавать и применять без перезагрузки системы. Сначала создаём файл `.te`, в котором описываем правила политики безопасности. Файл также должен содержать макрос `policy_module(name, version)` чтобы корректно назвать новый модуль. Далее нужно использовать Makefile из `/usr/share/selinux/devel/Makefile` чтобы скомпилировать файл командой `make module_name.pp`. Загрузка модуля производится командой `semodule -i module_name.pp`.


## Список источников: {#список-источников}

1.  <https://github.blog/2023-07-05-introduction-to-selinux>
